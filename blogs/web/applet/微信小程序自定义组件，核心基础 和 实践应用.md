---
title: 微信小程序自定义组件，核心基础 和 实践应用
date: 2023-10-28
sidebar: "auto"
categories:
  - applet
tags:
  - applet
publish: true
---

# 微信小程序自定义组件，核心基础 和 实践应用



从本节内容开始学习微信小程序的自定义组件，在实际项目开发中自定义组件也是经常用到的，同样是组件化看开发必备的技能。

我们前面已经实现了部分项目的开发，会发现代码中会出现潜在的重复实现，而小程序中提供的自定义组件机制就能很好的帮我们解决这个问题。

- 自定义组件的基本概念 和 用法
- 自定义组件 - 模板和样式
- 自定义组件 - 数据、方法、属性
- 自定义组件 - 数据监听器
- 自定义组件 - 纯数据字段
- 自定义组件 - 生命周期、生命周期函数
- 自定义组件 - 插槽
- 自定义组件 - 父子组件之间的通信
- 自定义组件 - behaviors

## 一、自定义组件的基本概念



开发者可以将页面内的功能模块抽象成自定义组件，以便在不同的页面中**重复使用**；也可以将复杂的页面拆分成多个低耦合的模块，**有助于代码维护**。自定义组件在使用时与基础组件非常相似。

> 详细查阅 [微信小程序官方文档 - 自定义组件(opens new window)](https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/)

### 1、创建自定义组件



类似于页面，一个自定义组件由 `json` `wxml` `wxss` `js` 4 个文件组成。创建步骤如下

- ①、在项目的根目录中，鼠标右键，创建 `components` 文件夹
- ②、在新建的 `components` 文件夹中再创建对应组件的文件夹，如 `tabs` 文件夹
- ③、在新建的 `components -> tabs` 文件夹上，鼠标右键 选择 `新建 Component`
- ④、输入组件的名称 `tabs` 后回车，会自动生成对应的 4 个文件，后缀名分别为 `json` `wxml` `wxss` `js`

> 注：
>
> 为了保证组件的目录结构清晰，且后期易于维护和管理，我们会把不同的组件存放到单独的目录中

![image-20230415184224793](https://www.arryblog.com/assets/img/image-20230415184224793.aaf419d5.png)

### 2、引用自定义组件



自定义组件的引用方式分为 **局部引用** 和 **全局引用**

- 局部引用：组件只能在当前被引用的页面内使用
- 全局引用：组件可以在每个小程序页面中使用

### 2.1、局部引用 和 使用自定义组件



在页面的 `.json` 配置文件中引用组件的方式，叫做 **局部引用**

在页面配置文件 `pages/index/index.json` 中引入 `tabs` 组件

```json
{
  "usingComponents": {
    "i-tabs": "/components/tabs/tabs"
  }
}
```

注：

引入组件时，需要定义一个自定组件的名称 如 `i-tabs` ，命名最佳实践建议以 `字母开头-组件名称`

在页面 `pages/index/index.wxml` 中使用组件

```html
<!--pages/index/index.wxml-->
<!-- 使用 tabs 自定义组件 -->
<i-tabs></i-tabs>
```

![image-20230415205803147](https://www.arryblog.com/assets/img/image-20230415205803147.a4cd4a09.png)

### 2.2、全局引用 和 使用自定义组件



在 `app.json` 全局配置文件中引用组件的方式，叫做 **全局引用**

> 凡是在全局 `app.json` 中引用的自定义组件，在项目的所有页面都可以使用该组件

```json
{
  "pages": [],
  "window": {},
  "tabBar": {},
  "usingComponents": {
    "i-amount": "/components/amount/amount"
  },
  "style": "v2",
  "sitemapLocation": "sitemap.json"
}
```

注：

在全局 `app.json` 配置文件中，新增节点 `usingComponents` 与 `pages` 节点平级即可全局引用自定义组件

在项目中的所有 `.wxml` 页面中都可以使用该全局引用的自定义组件

```html
<!-- 使用全局引用的 amount 自定义组件 -->
<i-amount></i-amount>
```

![image-20230415211215203](https://www.arryblog.com/assets/img/image-20230415211215203.e03b2661.png)

### 3、全局引用 VS 局部引用 的应用场景



根据组件的使用频率 和 范围，来选择合适的引用方式

- 如果某组件在多个页面中经常被用到，建议进行 **全局引用**
- 如果某组件只在特定的页面中被用到，建议进行 **局部引用**

### 4、自定义组件和页面的区别



从表面来看，组件和页面都是 `json` `wxml` `wxss` `js` 这 4 个文件组成的。但，组件和页面的 `.js` 与 `.json` 文件有明显的的不同

- 组件的 `.json` 文件中需要声明 `"component": true` 属性
- 组件的 `.js` 文件中调用的是 `Component()` 函数
- 组件的事件处理函数需要定义到 `methods` 节点中

## 二、自定义组件 - 模板和样式



类似于页面，自定义组件拥有自己的 `wxml` 模板和 `wxss` 样式。

> 详细查阅 [微信小程序官方文档 - 组件模板和样式(opens new window)](https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/wxml-wxss.html)

### 1、自定义组件的模板



组件模板的写法与页面模板相同。组件模板与组件数据结合后生成的节点树，将被插入到组件的引用位置上。

在组件模板中可以提供一个 `<slot>` 节点（即：插槽），用于承载组件引用时提供的子节点。

> 后边会有专门的章节来细讲插槽的用法

### 2、自定义组件样式隔离



默认情况下，自定义组件的样式只对当前组件生效，不会影响到组件之外的 UI 结构

![image-20230415215030189](data:image/png;base64,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)

上图所示

- 组件 A 的样式不会影响组件 B、C 的样式
- 组件 A、B、C 的样式也不会影响小程序页面的样式
- 小程序页面的样式同时也不会影响组件 A、B、C 的样式

**这样设计的好处：**

- 防止外界的样式影响组件内部的样式
- 防止组件内部的样式破坏外界页面的样式

### 3、自定义组件样式隔离的注意事项



- `app.wxss` 中的全局样式对自定义组件无效
- 只有 class 选择器会有样式隔离效果，id 选择器、属性选择器、标签选择器不受样式隔离的影响

**官方说明**

默认情况下，自定义组件的样式只受到自定义组件 wxss 的影响。除非以下两种情况：

- `app.wxss` 或页面的 `wxss` 中使用了标签名选择器（或一些其他特殊选择器）来直接指定样式，这些选择器会影响到页面和全部组件。通常情况下这是不推荐的做法
- 指定特殊的样式隔离选项 `styleIsolation`

最佳实践

在**组件** 和 **引用组件的页面** 中推荐使用 class 选择器， **不要使用 id 、属性 、标签选择器**

### 4、修改自定义组件的样式隔离选项



默认情况下，自定义组件的样式隔离特性能够防止组件内外样式互相不干扰的问题。

但有时候我们希望在外界能够控制组件内部的样式，可通过 `styleIsolation` 属性修改自定义组件的样式隔离选项

```js
Component({
  options: {
    styleIsolation: "isolated",
  },
});
```

从小程序基础库版本 [2.10.1 (opens new window)](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html)开始，也可以在页面或自定义组件的 json 文件中配置 `styleIsolation` （这样就不需在 js 文件的 `options` 中再配置）

```json
{
  "styleIsolation": "isolated"
}
```

### 5、styleIsolation 的可选值

| 可选值       | 默认值 | 描述                                                                                                                                                             |
| :----------- | :----- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| isolated     | 是     | 表示启用样式隔离，在自定义组件内外，使用 class 指定的样式将不会相互影响                                                                                          |
| apply-shared | 否     | 表示页面 wxss 样式将影响到自定义组件，但自定义组件 wxss 中指定的样式不会影响页面                                                                                 |
| shared       | 否     | 表示页面 wxss 样式将影响到自定义组件，自定义组件 wxss 中指定的样式也会影响页面和其他设置了 `apply-shared` 或 `shared` 的自定义组件。（这个选项在插件中不可用。） |

## 三、自定义组件 - 数据、方法、属性



`Component` 构造器可用于定义组件，调用 `Component` 构造器时可以指定组件的属性、数据、方法等。

> 详细查阅 [微信小程序官方文档 - Component 构造器(opens new window)](https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/component.html)

### 1、data 数据



在小程序自定义组件中，用于组件模板渲染的私有数据，需要定义到 data 节点中

```js
// components/tabs/tabs.js
Component({
  /**
   * 组件的初始数据
   */
  data: {
    count: 0,
  },
});
```

### 2、methods 方法



在小程序自定义组件中，事件处理函数 和 自定义方法需要定义到 methods 节点中

在自定义组件 `components/tabs/tabs.js` 逻辑中

```js
// components/tabs/tabs.js
Component({
  /**
   * 组件的初始数据
   */
  data: {
    count: 0,
  },

  /**
   * 组件的方法列表
   * 包含了：事件处理函数 和 自定义方法
   */
  methods: {
    // 事件处理函数
    addCount() {
      // 更新 data 中的 count 值
      this.setData({
        count: this.data.count + 1,
      });
      // 通过 this 调用 自定义方法
      this._showCount();
    },
    // 自定义方法，推荐使用 _ 开头
    _showCount() {
      wx.showToast({
        title: `count 的值是：${this.data.count}`,
        icon: "none",
      });
    },
  },
});
```

在自定义组件 `components/tabs/tabs.wxml` 页面结构中

```html
<!--components/tabs/tabs.wxml-->
<text class="tabs-item">我是 tabs 自定义组件</text>

<view>count 的值是：{{ count }}</view>
<button type="primary" bindtap="addCount">点我 + 1</button>
```

注：

以上自定义方法最佳实践，推荐使用 `_` 开头，可区分事件处理函数

### 3、properties 属性



在小程序中，properties 是自定义组件的对外属性，**用来接收外界传递到组件中的数据**

```js
// components/tabs/tabs.js
Component({
  /**
   * 组件的属性列表
   */
  properties: {
    // 完整定义属性的方式（当需要指定属性默认值时，推荐使用该方式）
    max: {
      type: Number, // 属性值的数据类型
      value: 100, // 属性的默认值
    },
    // 简化定义属性的方式（不需要指定属性默认值时，可使用简化方式）
    max: Number,
  },
});
```

在页面 `pages/index/index.wxml` 页面中使用 `tabs` 自定义组件时，

```html
<!-- 使用 tabs 自定义组件，并传递 max 属性值 -->
<i-tabs max="16"></i-tabs>
```

### 4、properties 属性的应用



将以上 max 作为 点击按钮 `+1` 的最大值判断条件

在自定义组件 `components/tabs/tabs.js` 中

```js
// components/tabs/tabs.js
Component({
  /**
   * 组件的属性列表
   */
  properties: {
    // 完整定义属性的方式（当需要指定属性默认值时，推荐使用该方式）
    max: {
      type: Number, // 属性值的数据类型
      value: 100, // 属性的默认值
    },
    // 简化定义属性的方式（不需要指定属性默认值时，可使用简化方式）
    // max: Number
  },

  /**
   * 组件的初始数据
   */
  data: {
    count: 0,
  },

  /**
   * 组件的方法列表
   * 包含了：事件处理函数 和 自定义方法
   */
  methods: {
    // 事件处理函数
    addCount() {
      // 判断如果 当前的 count >= max 值时，直接 return ，不再自增 + 1
      if (this.data.count >= this.properties.max) return;
      // 更新 data 中的 count 值
      this.setData({
        count: this.data.count + 1,
      });
      // 通过 this 调用 自定义方法
      this._showCount();
    },
    // 自定义方法，推荐使用 _ 开头
    _showCount() {
      wx.showToast({
        title: `count 的值是：${this.data.count}`,
        icon: "none",
      });
    },
  },
});
```

在自定义组件 `components/tabs/tabs.wxml` 页面结构中

```html
<!--components/tabs/tabs.wxml-->
<text class="tabs-item">我是 tabs 自定义组件</text>

<view>count 的值是：{{ count }}</view>
<button type="primary" bindtap="addCount">点我 + 1</button>
```

在页面 `pages/index/index.wxml` 中，使用 `tabs` 自定义组件

```html
<!--pages/index/index.wxml-->
<!-- 使用 tabs 自定义组件，并传递 max 属性值 -->
<i-tabs max="16"></i-tabs>
```

### 5、data 和 properties 的区别



- 在 Vue 中 data 是组件的私有数据，properties 是外界传递到内部的数据。其中**data 是可读可写的，properties 是只读的** 。详细查阅 [Vue 官方文档 - Props(opens new window)](https://cn.vuejs.org/guide/components/props.html)
- 在小程序的自定义组件中，properties 属性 和 data 数据的用法相同，**它们都是可读可写的**，这点与 Vue 有些差异。

> 不过，在小程序的自定义组件中（以下两点与 Vue 类似）

- `data` 更倾向于 **存储组件的私有数据**
- `properties` 更倾向于 **存储外界传递到组件中的数据**

验证小程序自定义组件中 properties 和 data 都是可读可写的，只是我们人为做了划分，如以上两点所说

```js
// components/tabs/tabs.js
Component({

    // ......

    methods: {

        // 页面点击 事件处理函数
        getInfo(){
            // 输出结果 {count: 0, max: 16}
            console.log(this.data);
            // 输出结果 {count: 0, max: 16}
            console.log(this.properties);
            // 输出结果 true ，证明 data 数据 和 properties 属性，本质上是一样的，都是可读可写的
            console.log(this.data === this.properties)
        }
    }

}）
<!--components/tabs/tabs.wxml-->
<button type="primary" bindtap="getInfo">点我，点我</button>
```

### 6、使用 setData 修改 properties 属性的值



由于 `data` 数据 和 `properties` 属性在本质上没有任何区别，因此 `properties` 属性的值也可以用于页面渲染 或 使用 `setData` 为 `properties` 中的属性重新赋值。

在自定义组件 `components/amount/amount.js` 逻辑中

```js
// components/amount/amount.js
Component({
  /**
   * 组件的属性列表
   */
  properties: {
    max: {
      type: Number,
      value: 9,
    },
  },

  /**
   * 组件的初始数据
   */
  data: {
    count: 0,
  },

  /**
   * 组件的方法列表
   */
  methods: {
    addCount() {
      this.setData({
        count: this.data.count + 1,
        // 给 properties 中的 max 属性重新赋值
        max: this.properties.max + 1,
      });
    },
  },
});
```

在自定义组件 `components/amount/amount.wxml` 页面结构中

```html
<!--components/amount/amount.wxml-->
<view>我是 amount 自定义组件</view>

<view>count 的值：{{ count }}</view>
<!-- properties 中定义的 max 属性也可以用于页面的渲染 -->
<view>max 属性的值是：{{ max }}</view>
<button type="primary" bindtap="addCount">点我 +1</button>
```

在页面 `pages/menu/menu.wxml` 中引用 `amount`自定义组件

```html
<!--pages/menu/menu.wxml-->
<!-- 使用 amount 自定义组件，并传递 max 属性值 -->
<i-amount max="12"></i-amount>
```

## 四、自定义组件 - 数据监听器



深入浅出自定义组件中的数据监听器的用法，监听字段、监听对象属性、监听对象中所有的属性变化，以及综合实践应用等

> 详细查阅 [微信小程序官方文档 - 数据监听器(opens new window)](https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/observer.html)

### 1、什么是数据监听器



数据监听器用于 **监听和响应任何属性和数据字段的变化**，从而执行特定的操作。它的作用类似于 [Vue 中的 watch 侦听器(opens new window)](https://cn.vuejs.org/guide/essentials/watchers.html)

在小程序中，数据监听器的语法如下

```js
Component({
  // 数据监听器节点
  observers: {
    "字段A, 字段B": function (字段A的新值, 字段B的新值) {
      // ... 执行特定的操作
    },
  },
});
```

### 2、数据监听器的用法 - 监听字段



需求：当点击 numA 按钮 或 numB 按钮时，实现自动计算结果。

> 新建自定义组件 `count` 如下

在自定义组件的`components/count/count.wxml` UI 结构中

```html
<!--components/count/count.wxml-->

<view>{{ numA }} + {{ numB }} = {{ sum }}</view>

<button type="primary" bindtap="addNumA">点我 numA +1</button>
<button type="primary" bindtap="addNumB">点我 numB +1</button>
```

在自定义组件的 `components/count/count.js` 逻辑中，实现 numA 和 numB 的数据监听

```js
// components/count/count.js
Component({
  // 组件的属性列表
  properties: {},

  // 组件的初始数据
  data: {
    numA: 0,
    numB: 0,
    sum: 0,
  },

  // 组件的方法列表
  methods: {
    addNumA() {
      this.setData({
        numA: this.data.numA + 1,
      });
    },
    addNumB() {
      this.setData({
        numB: this.data.numB + 1,
      });
    },
  },
  // 数据监听
  observers: {
    // 监听 numA 和 numB 数据的变化
    "numA, numB": function (newNumA, newNumB) {
      // 更新 sum 的值
      this.setData({
        sum: newNumA + newNumB, // 通过监听器，自动计算 sum 的值
      });
    },
  },
});
```

在页面配置`pages/index/index`中引入自定义组件 `count`

```json
{
  "usingComponents": {
    "i-count": "/components/count/count"
  }
}
```

在页面 `pages/index/index` 中使用自定义组件 `count`

```html
<!--pages/index/index.wxml-->

<i-count></i-count>
```

### 3、监听对象属性的变化



数据监听器支持监听对象中**单个** 或 **多个属性**的变化。

> 具体语法如下

```js
Component({
  // 数据监听器节点
  observers: {
    "对象.属性A, 对象.属性B": function (属性A的新值, 属性B的新值) {
      // 触发此监听器的 三种情况
      // 1、为属性A赋值 使用 setData 设置 this.data.对象.属性A 时触发
      // 2、为属性B赋值 使用 setData 设置 this.data.对象.属性B 时触发
      // 3、直接为对象赋值 使用 setData 设置 this.data.对象 时触发
      // ..... 执行特定的操作
    },
  },
});
```

### 4、数据监听器的实践应用



需求：实现点击不同的按钮实现颜色值的自增，同时实现背景颜色值的变化

![GIF-2023-4-16-4-38-06](https://www.arryblog.com/assets/img/GIF-2023-4-16-4-38-06.d9f664c1.gif)

### 4.1、新建 color 自定义组件



- ①、在 `components` 文件夹中 新建 `color` 自定义组件
- ②、在页面中引入 和 使用自定义组件 `color`

在页面配置`pages/index/index`中引入自定义组件 `color`

```json
{
  "usingComponents": {
    "i-color": "/components/color/color"
  }
}
```

在页面 `pages/index/index` 中使用自定义组件 `color`

```html
<!--pages/index/index.wxml-->

<i-count></i-count>
```

> 此时，就可以在 index 页面中 展示出来 `color` 自定义组件了

### 4.2、渲染 UI 结构 和 定义组件样式

在自定义组件 `components/color/color.wxml` UI 结构中

```html
<!--components/color/color.wxml-->

<view class="container-color" style="background-color: rgb({{ fullColor }});">
  颜色值：{{ fullColor }}
</view>

<!-- <view>{{ rgb.r }} ，{{ rgb.g }} ，{{ rgb.b }}</view> -->

<button bindtap="handleChangeR" size="mini" type="warn">R</button>
<button bindtap="handleChangeG" size="mini" type="default">G</button>
<button bindtap="handleChangeB" size="mini" type="primary">B</button>
```

在自定义组件 `components/color/color.wxss` 中定义样式

```css
/* components/color/color.wxss */
.container-color {
  height: 300rpx;
  background-color: skyblue;
  display: flex;
  justify-content: center;
  align-items: center;
  font-size: 40rpx;
}
button {
  margin: 10rpx;
}
```

### 4.3、定义 button 按钮的事件处理函数

在自定义组件 `components/color/color.js` 的逻辑中，定义对应的事件处理函数

```js
// components/color/color.js
Component({
  // 组件的属性列表
  properties: {},

  // 组件的初始数据
  data: {
    // rgb 颜色值对象
    rgb: {
      r: 0,
      g: 0,
      b: 0,
    },
    // 根据 rgb 对象的三个属性，动态计算 fullColor 的值
    fullColor: "0, 0, 0",
  },

  // 组件的方法列表
  methods: {
    // R 按钮 事件处理函数，修改 rgb 对象上的 r 属性值
    handleChangeR() {
      this.setData({
        "rgb.r": this.data.rgb.r + 30 > 255 ? 255 : this.data.rgb.r + 30,
      });
    },
    // G 按钮 事件处理函数，修改 rgb 对象上的 g 属性值
    handleChangeG() {
      this.setData({
        "rgb.g": this.data.rgb.g + 30 > 255 ? 255 : this.data.rgb.g + 30,
      });
    },
    // B 按钮 事件处理函数，修改 rgb 对象上的 b 属性值
    handleChangeB() {
      this.setData({
        "rgb.b": this.data.rgb.b + 30 > 255 ? 255 : this.data.rgb.b + 30,
      });
    },
  },
});
```

> 此时，当点击 R、G、B 三个按钮时，并没有任何变化，是因为我们并没有做任何展示。

只需要在页面上展示即可 ，在组件的 UI 结构中展示

```html
<view>{{ rgb.r }} ，{{ rgb.g }} ，{{ rgb.b }}</view>
```

### 4.4、监听对象中指定属性的变化

在自定义组件 `components/color/color.js` 的逻辑中，新增 observers 数据监听节点

```js
// components/color/color.js
Component({
  // 数据监听
  observers: {
    // 监听 rgb 对象上 r , g , b 三个子属性的变化
    "rgb.r, rgb.g, rgb.b": function (r, g, b) {
      this.setData({
        // 为 data 中的 fullColor 重新赋值
        fullColor: `${r}, ${g}, ${b}`,
      });
    },
  },
});
```

### 5、监听对象中所有属性的变化



如果某个对象中需要被监听的属性太多，为了方便可以使用通配符 `**` 来监听对象中所有属性的变化

```js
// 数据监听
observers: {
    // 使用 通配符 ** 来监听对象上所有属性的变化
    'rgb.**': function(obj){
        this.setData({
            // 为 data 中的 fullColor 重新赋值
            fullColor: `${obj.r}, ${obj.g}, ${obj.b}`
        })
    }
}
```

## 五、自定义组件 - 纯数据字段



深入浅出小程序中自定义组件的 纯数据字段，使用规则，以及实践应用案例

### 1、什么是纯数据字段



纯数据字段是一些不用于界面渲染的 data 字段

> 如：以上的 color 自定义组件 data 中的 rgb 对象就不用于页面展示使用，因此就适合定义为纯数据字段

- 应用场景：某些 data 中的字段 **既不会展示在界面上，也不会传递给其他组件** ，仅仅在当前组件内部使用。带有这种特性的 data 字段就适合被设置为 纯数据字段
- 好处：纯数据字段 **有助于提升页面更新的性能**

> 详细查阅 [微信小程序官方文档 - 纯数据字段(opens new window)](https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/pure-data.html)

### 2、使用规则



在 Component 构造器的 options 节点中，指定 `pureDataPattern` 为一个 **正则表达式** ，字符名 符合这个正则表达式的字段将成为纯数据字段

在自定义组件 `components/amount/amount.js` 中

```js
// components/amount/amount.js
Component({
  options: {
    // 指定所有 _ 开头的数据字段为纯数据字段
    pureDataPattern: /^_/,
  },
  // 组件的初始数据s
  data: {
    a: true, // 普通数据字段
    _b: true, // 纯数据字段（不用于界面的展示，也不会被展示）
  },
});
```

在自定义组件 `components/amount/amount.wxml` UI 结构中

```html
<!--components/amount/amount.wxml-->
<view>我是 amount 自定义组件</view>

<view wx:if="{{a}}"> 这行会被展示</view>
<view wx:if="{{_b}}"> 这行不会被展示 </view>
```

### 3、使用纯数据字段改造数据监听器应用案例



- ①、定义规则，指定所有`_`开头的数据字段为纯数据字段
- ②、将 rgb 颜色值对象 改造为以 `_` 开头的 `_rgb` 纯数据字段
- ③、将所有用到的以 rgb 开头的对象都修改为 `_rgb` ，可使用快捷键 `Ctrl + D` 快速选中所有以 `rgb` 开头的字段

改造 `components/color/color.js` 组件

```js
// components/color/color.js
Component({
  options: {
    // 指定所有 _ 开头的数据字段为纯数据字段
    pureDataPattern: /^_/,
  },

  // 组件的初始数据
  data: {
    // 将 rgb 颜色值对象 改造为以 _ 开头的纯数据字段
    _rgb: {
      r: 0,
      g: 0,
      b: 0,
    },
    // 根据 rgb 对象的三个属性，动态计算 fullColor 的值
    fullColor: "0, 0, 0",
  },

  // 组件的方法列表
  methods: {
    // R 按钮 事件处理函数，修改 rgb 对象上的 r 属性值
    handleChangeR() {
      this.setData({
        "_rgb.r": this.data._rgb.r + 30 > 255 ? 255 : this.data._rgb.r + 30,
      });
    },
    // G 按钮 事件处理函数，修改 rgb 对象上的 g 属性值
    handleChangeG() {
      this.setData({
        "_rgb.g": this.data._rgb.g + 30 > 255 ? 255 : this.data._rgb.g + 30,
      });
    },
    // B 按钮 事件处理函数，修改 rgb 对象上的 b 属性值
    handleChangeB() {
      this.setData({
        "_rgb.b": this.data._rgb.b + 30 > 255 ? 255 : this.data._rgb.b + 30,
      });
    },
  },

  // 数据监听
  observers: {
    // 使用 通配符 ** 来监听对象上所有属性的变化
    "_rgb.**": function (obj) {
      this.setData({
        // 为 data 中的 fullColor 重新赋值
        fullColor: `${obj.r}, ${obj.g}, ${obj.b}`,
      });
    },
  },
  // observers: {
  //     // 监听 rgb 对象上 r , g , b 三个子属性的变化
  //     'rgb.r, rgb.g, rgb.b': function(r, g, b){
  //        this.setData({
  //            // 为 data 中的 fullColor 重新赋值
  //            fullColor: `${r}, ${g}, ${b}`
  //        })
  //     }
  // }
});
```

## 六、自定义组件 - 生命周期



组件的生命周期，指的是组件自身的一些函数，这些函数在特殊的时间点或遇到一些特殊的框架事件时被自动触发。

> 详细查阅 [微信小程序自定义组件 - 组件生命周期(opens new window)](https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/lifetimes.html)

### 1、自定义组件的全部生命周期函数

| 生命周期 | 参数           | 描述                                     |
| :------- | :------------- | :--------------------------------------- |
| created  | 无             | 在组件实例刚刚被创建时执行               |
| attached | 无             | 在组件实例进入页面节点树时执行           |
| ready    | 无             | 在组件在视图层布局完成后执行             |
| moved    | 无             | 在组件实例被移动到节点树另一个位置时执行 |
| detached | 无             | 在组件实例被从页面节点树移除时执行       |
| error    | `Object Error` | 每当组件方法抛出错误时执行               |

### 2、自定义组件中主要（最重要）的生命周期函数



在小程序自定义组件中，最重要的生命周期函数有 3 个，分别是 `created` `attached` `detached` ，包含一个组件实例生命流程的最主要时间点。

①、组件实例**刚被创建好**的时候，created 生命周期函数会被触发

- 此时还不能调用 setData
- 通常在这个生命周期函数中，只应该用于给组件的 this 添加一些自定义的属性字段

②、在组件**完全初始化完毕、进入页面节点树后**，attached 生命周期函数会被触发

- 此时， `this.data` 已被初始化完毕
- 这个生命周期很有用，绝大多数初始化的工作可以在这个时机进行（例如发请求获取初始数据）

③、在组件**离开页面节点树后**，detached 生命周期函数会被触发

- 退出一个页面时，会触发页面内每个自定义组件的 detached 生命周期函数
- 此时适合做一些清理性质的工作

### 3、定义生命周期函数的方法



在小程序自定义组件中，生命周期方法可以直接定义在 `Component` 构造器的第一级参数中。可以在 `lifetimes` 字段内进行声明（这是推荐的方式，其优先级最高）

```js
Component({
  lifetimes: {
    attached: function () {
      // 在组件实例进入页面节点树时执行
    },
    detached: function () {
      // 在组件实例被从页面节点树移除时执行
    },
  },

  // 以下是旧式的定义方式，可以保持对 <2.2.3 版本基础库的兼容
  attached: function () {
    // 在组件实例进入页面节点树时执行
  },
  detached: function () {
    // 在组件实例被从页面节点树移除时执行
  },
  // ...
});
```

注：

如果新两种方式都存在的情况下，只会执行新的方式。同时官方已不推荐使用旧方式定义生命周期函数了。

### 4、自定义组件所在页面的生命周期



还有一些特殊的生命周期，它们并非与自定义组件有很强的关联，但有时自定义组件需要获知，以便组件内部处理。这样的生命周期称为“自定义组件所在页面的生命周期”

通俗的说：**自定义组件的行为依赖于页面状态的变化**，此时就需要用到**自定义组件所在页面的生命周期**。

> 如：以上监听器的案例中，需要每当触发页面的 show 生命周期函数时，我们希望能够重新生成一个随机的 RGB 颜色值

在自定义组件中，组件所在页面的生命周期函数有

| 生命周期函数 | 参数          | 描述                           |
| :----------- | :------------ | :----------------------------- |
| show         | 无            | 组件所在的页面被展示时执行     |
| hide         | 无            | 组件所在的页面被隐藏时执行     |
| resize       | `Object Size` | 组件所在的页面尺寸变化时执行   |
| routeDone    | 无            | 组件所在页面路由动画完成时执行 |

注：

以上生命周期函数，需要在自定义组件的 `pageLifetimes` 节点中定义。同时，自定义 tabBar 的 pageLifetimes 不会触发

### 4.1、自定义组件所在页面的生命周期 - pageLifetimes 节点



自定义组件所在页面的生命周期函数，需要定义在 pageLifetimes 节点中

```js
pageLifetimes: {

    show: function() {
        // 页面被展示
        console.log("show 页面被展示")
    },
    hide: function() {
        // 页面被隐藏
        console.log("hide 页面被隐藏")
    },
    resize: function(size) {
        // 页面尺寸变化
        console.log("resize 页面尺寸变化");
    }

}
```

### 4.2、实践应用 - 在页面展示时为其中的自定义组件更新数据



需求：再次为 监听器应用案例，在页面展示时为其中的自定义组件 生成随机的 RGB 颜色值

```js
// components/color/color.js
Component({
  // ... 其余代码省略

  // 组件的方法列表
  methods: {
    // 随机生成 RGB 颜色值的方法，非事件处理函数 以 _ 开头
    _randomColor() {
      // 为 data 中的 _rgb 纯数据字段重新赋值
      this.setData({
        _rgb: {
          r: Math.floor(Math.random() * 256),
          g: Math.floor(Math.random() * 256),
          b: Math.floor(Math.random() * 256),
        },
      });
    },
  },

  // 自定义组件生命周期定义
  pageLifetimes: {
    // 自定义组件所在页面被展示时，立即调用 _randomColor() 生成随机颜色值
    show: function () {
      this._randomColor();
    },
  },
});
```

效果如下

![GIF-2023-4-16-6-20-41](https://www.arryblog.com/assets/img/GIF-2023-4-16-6-20-41.ce5d0892.gif)

## 七、自定义组件 - 插槽



深入浅出小程序中自定义组件的插槽，单个插槽、多个插槽的定义和使用等

> 在小程序自定义组件中的插槽 类似 [Vue 中的 插槽 Slots(opens new window)](https://cn.vuejs.org/guide/components/slots.html)

### 1、什么是插槽



在自定义组件的 WXML 结构中，提供了一个 `<slot>` 节点（插槽）**用于承载组件使用者提供的 WXML 结构**

![image-20230416065026651](https://www.arryblog.com/assets/img/image-20230416065026651.453bc358.png)

注：

- 当我们封装一个自定义组件 A ，然后在页面中去使用这个组件
- 作为组件的封装者，其中的某一部分节点，我们并不知道要填写什么内容。此时，将不知道填写什么内容的部分使用一个 `<slot>` 插槽来占位
- 外界在使用自定义组件时，使用者可以向占位符中填充具体的内容
- 如上图，我们在页面中使用了两次自定义组件 A ，第一次使用时我们向插槽中填充了一个 `<view></view>` 组件，最终展示出来的就是一个 `view` 。第二次使用时向插槽中填充了一个 `<text></text>` 组件，最终展示出来的就是一个 `text`

> 我们可以看到通过插槽就可以做到允许封装者 定义一个 `<slot></slot>` 来提供内容占位，让使用者去填充具体的内容节点即可。这就是插槽的作用了 ！

### 2、自定义组件 - 单个插槽



在小程序中，默认每个自定义组件中只允许使用一个 `<slot>` 进行占位，这种个数上的限制叫做 **“单个插槽”**

创建一个自定义组件 `nav` ，在 `components/nav/nav.wxml` 定义插槽

```html
<!--components/nav/nav.wxml-->
<!-- 组件的封装者 -->
<view class="nav">
  <view>这里是组件的内部结构</view>
  <!-- 对于不确定的内容，可以使用 <slot> 进行占位，具体的内容由组件的使用者决定 -->
  <slot></slot>
</view>
```

在页面中，使用自定义组件 并通过插槽填充内容

```html
<!--pages/index/index.wxml-->

<!-- 组件的使用者 -->
<i-nav>
  <!-- 这部分内容将放置在组件 <slot> （插槽）的位置上 -->
  <view>这里是通过插槽填充的内容</view>
</i-nav>
```

### 3、自定义组件 - 启用多个插槽



在小程序的自定义组件中，需要使用多 `<slot>` 插槽时，可以在组件的 `.js` 文件中 先启用多 slot 支持

> 默认情况下，一个组件的 wxml 中只能有一个 slot 。需要使用多 slot 时，可以在组件 js 中声明启用。

```js
Component({
  options: {
    multipleSlots: true, // 在组件定义时的选项中启用多slot支持
  },
  properties: {
    /* ... */
  },
  methods: {
    /* ... */
  },
});
```

### 4、定义多个插槽



可以在这个组件的 wxml 中使用多个 slot ，以不同的 `name` 来区分不同的插槽。

在自定义组件 `components/nav/nav.wxml` 页面结构中定义多个插槽

```html
<!-- 组件模板 -->
<view class="nav">
  <!-- name 为 before 的第一个 slot 插槽 -->
  <slot name="before"></slot>
  <view>这里是组件的内部细节</view>
  <!-- name 为 after 的第二个 slot 插槽 -->
  <slot name="after"></slot>
</view>
```

### 5、使用多个插槽



在使用带有多个插槽的自定义组件时，需要用 `slot` 属性来将节点插入到不同的 `<slot>` 中

在页面`pages/index/index.html`中使用多个插槽

```html
<!--pages/index/index.wxml-->

<!-- 组件的使用者 -->
<i-nav>
  <!-- 这部分内容将被放置在组件 <slot name="before"> 的位置上 -->
  <view slot="before">这里是插入到组件 slot name="before" 中的内容</view>
  <!-- 这部分内容将被放置在组件 <slot name="after"> 的位置上 -->
  <view slot="after">这里是插入到组件 slot name="after" 中的内容</view>
</i-nav>
```

注：

在多插槽使用的过程中，与页面容器的顺序无关

## 八、自定义组件 - 父子组件之间的通信



深入浅出微信小程自定义组件中 父子组件之间通信的 3 种方式：属性绑定、事件绑定、通过 `this.selectComponent`获取自定义组件的实例

> 详细查阅 [微信小程序官方文档 - 组件间通信与事件(opens new window)](https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/events.html)

### 1、父子组件之间通信的 3 种方式



- ①、属性绑定（WXML 数据绑定）：用于**父组件向子组件**的指定属性设置数据，仅能设置 JSON 兼容数据（自基础库版本 [2.0.9 (opens new window)](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html)开始，还可以在数据中包含函数）。具体在 [组件模板和样式 (opens new window)](https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/wxml-wxss.html)章节中介绍。
- ②、事件绑定：用于**子组件向父组件**传递数据，可以传递任意数据。
- ③、获取组件实例：如果以上两种方式不足以满足需要，父组件还可以通过 `this.selectComponent` 方法获取子组件实例对象，这样就可以直接访问组件的任意数据和方法。

### 2、属性绑定（WXML 数据绑定） - 实现父子组件间的通信



属性绑定用于实现**父向子传值**，仅能设置 JSON 兼容数据（自基础库版本 [2.0.9 (opens new window)](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html)开始，还可以在数据中包含函数）

在父组件 index 页面逻辑 `pages/index/index.js` 中定义 count 属性值

```js
// pages/index/index.js

Page({
  // 父组件的 data 节点
  data: {
    count: 0,
  },
});
```

在父组件的 index 页面结构 `pages/index/index.wxml` 中渲染 count 值

```html
<!--pages/index/index.wxml-->
<view> 父组件中，count 的值为：{{ count }} </view>
```

新建一个自定义组件（子组件）名称为：son

```markdown
icoding-com
├─ components
│ ├─ son
│ │ ├─ son.js
│ │ ├─ son.json
│ │ ├─ son.wxml
│ │ └─ son.wxss
```

在父组件 index 页面 `pages/index/index.wxml` 中，使用子组件

```html
<!--pages/index/index.wxml-->
<view> 父组件中，count 的值为：{{ count }} </view>

<view>--------------------</view>

<!-- 使用子组件，并通过父组件 向 子组件传递 count 值 -->
<i-son count="{{ count }}"></i-son>
```

在子组件 `components/son/son.js` 逻辑中的 `properties` 节点中声明从外界传递过来属性

```js
// components/son/son.js
Component({
  // 组件的属性列表
  properties: {
    // 用来接收父组件传递给子组件的 count 属性
    count: {
      type: Number,
      value: 1,
    },
  },
});
```

在子组件 `components/son/son.wxml` UI 结构中，渲染由父组件传递过来的 count 属性

```html
<!--components/son/son.wxml-->
<text>components/son/son.wxml</text>

<view> 在子组件中接收父组件传递过来的 count 值：{{ count }} </view>
```

在父组件 `pages/index/index.json` 配置文件中，引入（注册）子组件

```json
{
  "usingComponents": {
    "i-son": "/components/son/son"
  }
}
```

### 3、实现子组件中属性值的操作



实现将以上案例的子组件中 count 属性值 自增 `+1`

在子组件 `components/son/son.wxml` UI 结构中，渲染由父组件传递过来的 count 属性

```html
<!--components/son/son.wxml-->
<text>components/son/son.wxml</text>

<view> 在子组件中接收父组件传递过来的 count 值：{{ count }} </view>

<!-- 在子组件中 添加一个 button 按钮，并绑定事件处理函数 -->
<button bindtap="addCount">点我 +1</button>
```

在子组件 `components/son/son.js` 逻辑中的 `methods` 节点中添加 事件处理函数

```js
// components/son/son.js
Component({
  // 组件的属性列表
  properties: {
    count: {
      type: Number,
      value: 1,
    },
  },

  // 组件的初始数据
  data: {},

  // 组件的方法列表
  methods: {
    // 点击 +1 按钮，事件处理函数
    addCount() {
      this.setData({
        count: this.properties.count + 1,
      });
    },
  },
});
```

注：

当点击子组件中按钮时，在子组件中的 count 值已实现自增 `+1` 了

> 但，子组件中的 count 值自增 `+1` 并么有同步到 父组件中。接下来就需要来实现 **子组件向父组件传值** ，这里我们就需要用到 **事件绑定** 的方式来实现 ！

### 4、事件绑定 - 实现父子组件间的通信



事件绑定用于**子组件向父组件**传递数据，可以传递任意数据。

> 实现步骤如下

- ①、在**父组件**的 JS 逻辑中，定义一个函数，这个函数将通过自定义事件的形式，传递给子组件
- ②、在**父组件**中的 WXML 结构中，通过自定义事件的形式，将步骤 ① 中定义的函数引用，传递给子组件
- ③、在**子组件**的 JS 逻辑中，通过调用 `this.triggerEvent('自定义事件名称',{ /* 参数对象 */ })` 将数据发送到父组件
- ④、在**父组件**的 JS 逻辑中，通过 `e.detail` 获取到子组件传递过来的数据

### 4.1、步骤 1 在父组件中，定义一个函数



在**父组件**的 JS 逻辑中，定义一个函数，这个函数将通过自定义事件的形式，传递给子组件

在父组件 `pages/index/index.js` 逻辑中

```js
// pages/index/index.js

Page({
  // 父组件的 data 节点
  data: {
    count: 0,
  },
  // 在父组件中定义 syncCount 方法
  // 这个方法会被传递给子组件，供子组件进行调用
  syncCount() {
    console.log("我是父组件中定义的 syncCount() 函数");
  },
});
```

> 接下来就开始 **对子组件进行事件绑定**

### 4.2、步骤 2 在父组件中，通过自定义事件的形式引用函数



在**父组件**中的 WXML 结构中，通过自定义事件的形式，将步骤 ① 中定义的函数引用，传递给子组件

在父组件 `pages/index/index.wxml` 中

```html
<!--pages/index/index.wxml-->
<view> 父组件中，count 的值为：{{ count }} </view>

<view>--------------------</view>

<!-- 使用子组件，并通过父组件 向 子组件传递 count 值 -->

<!-- 使用 bind:自定义事件名称 的形式 （推荐使用，结构更清晰）-->
<i-son count="{{ count }}" bind:sync="syncCount"></i-son>

<!-- 或 使用 bind 后面直接写上自定义事件名称 的形式 -->
<!-- <i-son count="{{ count }}" bindsync="syncCount"></i-son> -->
```

### 4.3、步骤 3 在组件中，调用 this.triggerEvent 将数据发送给父组件



在**子组件**的 JS 逻辑中，通过调用 `this.triggerEvent('自定义事件名称',{ /* 参数对象 */ })` 将数据发送到父组件

在子组件 `components/son/son.js` 中

```js
// components/son/son.js
Component({
  // 组件的属性列表
  properties: {
    count: {
      type: Number,
      value: 1,
    },
  },

  // 组件的初始数据
  data: {},

  // 组件的方法列表
  methods: {
    // 点击 +1 按钮，事件处理函数
    addCount() {
      this.setData({
        count: this.properties.count + 1,
      });

      // 在子组件中，当点击 +1 按钮时，触发从父组件中传递过来 sync 自定义事件，并将子组件的最新的 count 值传递到父组件中（等待父组件接收该值）
      this.triggerEvent("sync", { value: this.properties.count });
    },
  },
});
```

### 4.4、步骤 4 在父组件中，通过 e.detail 获取子组件的数据



在**父组件**的 JS 逻辑中，通过 `e.detail` 获取到子组件传递过来的数据

在 `pages/index/index.js` 中

```js
// pages/index/index.js

Page({
  // 父组件的 data 节点
  data: {
    count: 0,
  },
  // 在父组件中定义 syncCount 方法
  // 这个方法会被传递给子组件，供子组件进行调用
  syncCount(e) {
    console.log("我是父组件中定义的 syncCount() 函数");

    // 通过 e.detail 获取子组件通过 this.triggerEvent 传递过来的数据
    console.log(e.detail.value);
    // 将子组件中传递过来的最新 count 值，同步更新到 data
    this.setData({
      count: e.detail.value,
    });
  },
});
```

### 5、获取自定义组件的实例



可在父组件里调用 `this.selectComponent("id 或 class 选择器")` 获取子组件的实例对象，从而直接访问子组件的任意数据 和 方法。

调用时，需要传入一个选择器。如：`this.selectComponent(".component-son")`

在父组件页面 `pages/index/index.wxml` 中

```html
<!--pages/index/index.wxml-->
<view> 父组件中，count 的值为：{{ count }} </view>

<!-- 1、定义按钮，并绑定获取子组件实例的事件 -->
<button bindtap="getChild">获取子组件的实例</button>

<view>--------------------</view>

<!-- 2、给自定义组件，定义一个 class 或 id 选择器 -->
<i-son count="{{ count }}" bind:sync="syncCount" class="component-son"></i-son>
```

在父组件页面逻辑 `pages/index/index.js` 中

```js
// pages/index/index.js

Page({
  // 按钮的事件处理函数
  getChild() {
    // 获取自定义组件（子组件）的实例对象 class 类选择器使用 . 开头 ，id 选择器使用 # 开头
    const child = this.selectComponent(".component-son");
    // console.log(child)
    child.setData({
      // 调用子组件的 setData 方法
      count: child.properties.count + 1,
    });

    // 调用子组件的方法
    child.addCount();
  },
});
```

![image-20230417154541327](https://www.arryblog.com/assets/img/image-20230417154541327.961480d5.png)

## 九、自定义组件 - behaviors



深入浅出微信小程自定义组件中的 behaviors，工作方式、创建 behaviors，导入并使用 behaviors，behaviors 中所有的可用节点，同名字段的覆盖 和 组合规则

> 详细阅读 [微信小程序官方文档 - behaviors(opens new window)](https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/behaviors.html)

### 1、什么是 behaviors



`behaviors` 是微信小程序中，**用于组件间代码共享** 的特性，类似于 Vue 中的 “mixins”

![image-20230417161305147](https://www.arryblog.com/assets/img/image-20230417161305147.4e2b700c.png)

### 2、behaviors 的工作方式



每个 behaviors 可以包含一组 **属性、数据、生命周期函数** 和 **方法**。组件引用它时，它的属性、数据 和 方法 **会被合并到组件中**，**生命周期函数也会在对应时机被调用**

每个组件可以引用多个 `behavior` ，`behavior` 也可以引用其它 `behavior`

### 3、创建 behaviors



调用 `Behavior(Object object)` 构造器方法即可创建一个**共享的 behavior 实例对象** 供所有的组件导入使用

在项目的根目录中，创建`behaviors`文件夹，再创建一个 `my-behavior.js` 文件，目录结构如下

```markdown
icoding-com
├─ behaviors
│ └─ my-behavior.js
```

在 `behaviors/my-behavior.js` 文件中创建 behavior 实例对象

```js
// 调用 Behavior() 方法，创建实例对象
// 使用 module.exports 将 behavior 实例对象共享出去
module.exports = Behavior({
  // 私有数据节点
  data: {
    username: "arry老师",
    myBehaviorData: {},
  },
  // 属性节点
  properties: {},
  // 时间处理函数 和 自定义方法节点
  methods: {},

  // 其他节点（可查阅官方文档）
});
```

### 4、导入并使用 behavior



在自定义组件中，使用 `require()` 方法导入需要的 behavior ，挂载后即可访问 behavior 中的数据或方法

在自定义组件 `components/son/son.js` 中 导入定义好的 behavior 模块

```js
// components/son/son.js

// 1、使用 require() 导入需要的自定义 behavior 模块
const myBehavior = require("../../behaviors/my-behavior");

Component({
  // 2、将导入的 behavior 实例对象，挂载到 behaviors 数组节点中，即可生效
  behaviors: [myBehavior],

  // 组件的属性列表
  properties: {},
  // 组件的初始数据
  data: {},
  // 组件的方法列表
  methods: {},
});
```

在自定义组件 `components/son/son.wxml` UI 结构中渲染 behavior 中定义的数据

```html
<!--components/son/son.wxml-->

<view>在 behavior 中定义的用户名是：{{ username }}</view>
```

总结：

上面的示例，可以看到我们通过 behavior 确实可以在自定义组件之间来共享代码

原来定义一个数据只能在自定义内部的 data 节点中定义 或 定义属性需要在 properties 节点中定义。

而现在不一样，我们可以讲这些数据或属性等 抽离到一个共享的 behavior 实例对象上，使用时只需要在自定义组件的 JS 文件中导入进来 并 挂载到 behaviors 数组节点中，即可生效

### 5、behavior 中所有可用的节点



详细查阅 [微信小程序官方文档 - Behavior(Object object)(opens new window)](https://developers.weixin.qq.com/miniprogram/dev/reference/api/Behavior.html)

| 定义段     | 类型         | 是否必填 | 描述                                                                                                                                                                                                                          |
| :--------- | :----------- | :------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| properties | Object Map   | 否       | 同自定义组件的属性 组件的对外属性，是属性名到属性设置的映射表                                                                                                                                                                 |
| data       | Object       | 否       | 同自定义组件的数据 data 组件的内部数据，和 `properties` 一同用于组件的模板渲染                                                                                                                                                |
| methods    | Object       | 否       | 同自定义组件的方法 组件的方法，包括事件响应函数和任意的自定义方法，关于事件响应函数的使用，参见 [组件间通信与事件(opens new window)](https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/events.html) |
| behaviors  | String Array | 否       | 引入其它的 behavior 类似于 mixins 和 traits 的组件间代码复用机制，参见 [behaviors(opens new window)](https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/behaviors.html)                              |
| created    | Function     | 否       | 组件生命周期函数 在组件实例刚刚被创建时执行，注意此时不能调用 `setData`                                                                                                                                                       |
| attached   | Function     | 否       | 组件生命周期函数 在组件实例进入页面节点树时执行                                                                                                                                                                               |
| ready      | Function     | 否       | 组件生命周期函数 在组件布局完成后执行)                                                                                                                                                                                        |
| moved      | Function     | 否       | 组件生命周期函数 在组件实例被移动到节点树另一个位置时执行                                                                                                                                                                     |
| detached   | Function     | 否       | 组件生命周期函数 在组件实例被从页面节点树移除时执行                                                                                                                                                                           |
| .....      | .....        | .....    |                                                                                                                                                                                                                               |

> 注：前四个会常用些

### 6、behavior 中同名字段的覆盖 和 组合规则



组件和它引用的 `behavior` 中**可以包含同名的字段** ，其中有 3 种同名时的处理规则

- ①、同名的属性（properties）或 方法（methods）
- ②、同名的数据字段（data）
- ③、生命周期函数和 observers 不会相互覆盖，而是在对应触发时机被逐个调用

> 详细查阅 [微信小程序官方文档 - 同名字段的覆盖和组合规则(opens new window)](https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/behaviors.html)
