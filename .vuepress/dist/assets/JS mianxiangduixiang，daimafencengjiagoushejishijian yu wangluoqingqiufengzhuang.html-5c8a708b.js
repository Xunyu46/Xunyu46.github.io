const l=JSON.parse('{"key":"v-4085adf4","path":"/blogs/web/applet/JS mianxiangduixiang，daimafencengjiagoushejishijian yu wangluoqingqiufengzhuang.html","title":"JS 面向对象，代码分层架构设计实践 与 网络请求封装","lang":"en-US","frontmatter":{"title":"JS 面向对象，代码分层架构设计实践 与 网络请求封装","date":"2023-10-28T00:00:00.000Z","sidebar":"auto","categories":["applet"],"tags":["applet"],"publish":true},"headers":[{"level":2,"title":"一、JavaScript 面向对象 与 代码分层架构设计","slug":"一、javascript-面向对象-与-代码分层架构设计","link":"#一、javascript-面向对象-与-代码分层架构设计","children":[{"level":3,"title":"1、常规的实现方式","slug":"_1、常规的实现方式","link":"#_1、常规的实现方式","children":[]},{"level":3,"title":"2、什么是 模型","slug":"_2、什么是-模型","link":"#_2、什么是-模型","children":[]},{"level":3,"title":"3、模型的意义","slug":"_3、模型的意义","link":"#_3、模型的意义","children":[]},{"level":3,"title":"3.1、传统的方式","slug":"_3-1、传统的方式","link":"#_3-1、传统的方式","children":[]},{"level":3,"title":"3.2、改变调用链路","slug":"_3-2、改变调用链路","link":"#_3-2、改变调用链路","children":[]},{"level":3,"title":"4、软件工程最佳实践","slug":"_4、软件工程最佳实践","link":"#_4、软件工程最佳实践","children":[]},{"level":3,"title":"5、分层设计的好处","slug":"_5、分层设计的好处","link":"#_5、分层设计的好处","children":[]},{"level":3,"title":"6、发起网络请求","slug":"_6、发起网络请求","link":"#_6、发起网络请求","children":[]}]},{"level":2,"title":"二、wx.request 二次封装，实现统一响应和异常处理","slug":"二、wx-request-二次封装-实现统一响应和异常处理","link":"#二、wx-request-二次封装-实现统一响应和异常处理","children":[{"level":3,"title":"1、wx.request 封装","slug":"_1、wx-request-封装","link":"#_1、wx-request-封装","children":[]},{"level":3,"title":"2、全局统一响应、异常处理","slug":"_2、全局统一响应、异常处理","link":"#_2、全局统一响应、异常处理","children":[]},{"level":3,"title":"3、在模型类中调用封装好的 request 请求","slug":"_3、在模型类中调用封装好的-request-请求","link":"#_3、在模型类中调用封装好的-request-请求","children":[]},{"level":3,"title":"5、解决方法 一 ：回调函数","slug":"_5、解决方法-一-回调函数","link":"#_5、解决方法-一-回调函数","children":[]},{"level":3,"title":"5.1、什么是回调地狱","slug":"_5-1、什么是回调地狱","link":"#_5-1、什么是回调地狱","children":[]},{"level":3,"title":"5.2、同步编程","slug":"_5-2、同步编程","link":"#_5-2、同步编程","children":[]},{"level":3,"title":"5.3、异步编程","slug":"_5-3、异步编程","link":"#_5-3、异步编程","children":[]},{"level":3,"title":"6、回调地狱解决方案演进脉络","slug":"_6、回调地狱解决方案演进脉络","link":"#_6、回调地狱解决方案演进脉络","children":[]},{"level":3,"title":"6.1、使用 Promise 解决地狱回调","slug":"_6-1、使用-promise-解决地狱回调","link":"#_6-1、使用-promise-解决地狱回调","children":[]},{"level":3,"title":"6.2、小程序 API 的 Promise 化","slug":"_6-2、小程序-api-的-promise-化","link":"#_6-2、小程序-api-的-promise-化","children":[]},{"level":3,"title":"6.3、改造完善 Http 类中的方法","slug":"_6-3、改造完善-http-类中的方法","link":"#_6-3、改造完善-http-类中的方法","children":[]},{"level":3,"title":"7、async/await 终极解决方案","slug":"_7、async-await-终极解决方案","link":"#_7、async-await-终极解决方案","children":[]},{"level":3,"title":"7.1、async/await 的本质","slug":"_7-1、async-await-的本质","link":"#_7-1、async-await-的本质","children":[]},{"level":3,"title":"7.2、通过 async/await 改造完善 Http 类中的方法","slug":"_7-2、通过-async-await-改造完善-http-类中的方法","link":"#_7-2、通过-async-await-改造完善-http-类中的方法","children":[]},{"level":3,"title":"8、在页面逻辑中调用模型类中的方法","slug":"_8、在页面逻辑中调用模型类中的方法","link":"#_8、在页面逻辑中调用模型类中的方法","children":[]}]}],"git":{"createdTime":1698506571000,"updatedTime":1705051907000,"contributors":[{"name":"xunyu","email":"2548126293@qq.com","commits":2}]},"filePathRelative":"blogs/web/applet/JS 面向对象，代码分层架构设计实践 与 网络请求封装.md"}');export{l as data};
